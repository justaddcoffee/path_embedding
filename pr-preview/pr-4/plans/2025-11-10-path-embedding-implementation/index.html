
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://justaddcoffee.github.io/path-embedding/plans/2025-11-10-path-embedding-implementation/">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>Path Embedding Classifier Implementation Plan - path-embedding</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.84d31ad4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../css/ansi-colours.css">
    
      <link rel="stylesheet" href="../../css/jupyter-cells.css">
    
      <link rel="stylesheet" href="../../css/pandas-dataframe.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#path-embedding-classifier-implementation-plan" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="path-embedding" class="md-header__button md-logo" aria-label="path-embedding" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            path-embedding
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Path Embedding Classifier Implementation Plan
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/justaddcoffee/path-embedding" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="path-embedding" class="md-nav__button md-logo" aria-label="path-embedding" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    path-embedding
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/justaddcoffee/path-embedding" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#prerequisites" class="md-nav__link">
    <span class="md-ellipsis">
      Prerequisites
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Prerequisites">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-0-add-dependencies" class="md-nav__link">
    <span class="md-ellipsis">
      Task 0: Add Dependencies
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-1-data-models-and-path-extraction" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 1: Data Models and Path Extraction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 1: Data Models and Path Extraction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-11-define-core-data-models" class="md-nav__link">
    <span class="md-ellipsis">
      Task 1.1: Define Core Data Models
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-12-drugmechdb-data-loader" class="md-nav__link">
    <span class="md-ellipsis">
      Task 1.2: DrugMechDB Data Loader
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-13-networkx-multigraph-construction" class="md-nav__link">
    <span class="md-ellipsis">
      Task 1.3: NetworkX Multigraph Construction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-14-extract-paths-from-multigraph" class="md-nav__link">
    <span class="md-ellipsis">
      Task 1.4: Extract Paths from Multigraph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-2-text-formatting" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 2: Text Formatting
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 2: Text Formatting">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-21-path-to-text-conversion" class="md-nav__link">
    <span class="md-ellipsis">
      Task 2.1: Path to Text Conversion
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-3-negative-sampling" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 3: Negative Sampling
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 3: Negative Sampling">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-31-build-node-inventory" class="md-nav__link">
    <span class="md-ellipsis">
      Task 3.1: Build Node Inventory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-32-generate-negative-path" class="md-nav__link">
    <span class="md-ellipsis">
      Task 3.2: Generate Negative Path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-33-generate-full-negative-dataset" class="md-nav__link">
    <span class="md-ellipsis">
      Task 3.3: Generate Full Negative Dataset
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-4-openai-embeddings" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 4: OpenAI Embeddings
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 4: OpenAI Embeddings">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-41-openai-api-integration" class="md-nav__link">
    <span class="md-ellipsis">
      Task 4.1: OpenAI API Integration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-42-batch-path-embedding" class="md-nav__link">
    <span class="md-ellipsis">
      Task 4.2: Batch Path Embedding
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-5-traintest-split" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 5: Train/Test Split
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 5: Train/Test Split">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-51-indication-level-splitting" class="md-nav__link">
    <span class="md-ellipsis">
      Task 5.1: Indication-Level Splitting
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-6-classifier-training-and-evaluation" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 6: Classifier Training and Evaluation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 6: Classifier Training and Evaluation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-61-random-forest-classifier" class="md-nav__link">
    <span class="md-ellipsis">
      Task 6.1: Random Forest Classifier
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-62-evaluation-metrics" class="md-nav__link">
    <span class="md-ellipsis">
      Task 6.2: Evaluation Metrics
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-7-cli-integration" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 7: CLI Integration
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 7: CLI Integration">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-71-training-command" class="md-nav__link">
    <span class="md-ellipsis">
      Task 7.1: Training Command
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#phase-8-kgx-stub" class="md-nav__link">
    <span class="md-ellipsis">
      Phase 8: KGX Stub
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Phase 8: KGX Stub">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-81-kgx-loader-stub" class="md-nav__link">
    <span class="md-ellipsis">
      Task 8.1: KGX Loader Stub
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#final-steps" class="md-nav__link">
    <span class="md-ellipsis">
      Final Steps
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Final Steps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task-91-run-full-test-suite" class="md-nav__link">
    <span class="md-ellipsis">
      Task 9.1: Run Full Test Suite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-92-create-data-and-models-directories" class="md-nav__link">
    <span class="md-ellipsis">
      Task 9.2: Create Data and Models Directories
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#task-93-update-documentation" class="md-nav__link">
    <span class="md-ellipsis">
      Task 9.3: Update Documentation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#success-criteria" class="md-nav__link">
    <span class="md-ellipsis">
      Success Criteria
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#notes" class="md-nav__link">
    <span class="md-ellipsis">
      Notes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#execution" class="md-nav__link">
    <span class="md-ellipsis">
      Execution
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="path-embedding-classifier-implementation-plan">Path Embedding Classifier Implementation Plan</h1>
<blockquote>
<p><strong>For Claude:</strong> REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p>
</blockquote>
<p><strong>Goal:</strong> Build a binary classifier that distinguishes biologically plausible from implausible drug-disease mechanistic paths using LLM embeddings.</p>
<p><strong>Architecture:</strong> Extract paths from DrugMechDB multigraphs, convert to structured text, embed with OpenAI API, train Random Forest classifier. Generate negative examples via cross-disease shuffling with type matching. Split train/test at indication level to prevent leakage.</p>
<p><strong>Tech Stack:</strong> NetworkX (multigraphs), OpenAI embeddings API, scikit-learn (Random Forest), pytest (TDD), typer (CLI)</p>
<p><strong>Design Document:</strong> <a href="../2025-11-10-path-embedding-classifier-design/">2025-11-10-path-embedding-classifier-design.md</a></p>
<hr />
<h2 id="prerequisites">Prerequisites</h2>
<h3 id="task-0-add-dependencies">Task 0: Add Dependencies</h3>
<p><strong>Step 1: Add required dependencies</strong></p>
<p>Run:</p>
<pre><code class="language-bash">uv add networkx openai numpy scikit-learn pyyaml requests
</code></pre>
<p>Expected: Dependencies added to pyproject.toml and installed</p>
<p><strong>Step 2: Verify installation</strong></p>
<p>Run:</p>
<pre><code class="language-bash">uv run python -c &quot;import networkx, openai, numpy, sklearn, yaml, requests; print('All deps OK')&quot;
</code></pre>
<p>Expected: "All deps OK" printed</p>
<p><strong>Step 3: Commit</strong></p>
<pre><code class="language-bash">git add pyproject.toml uv.lock
git commit -m &quot;deps: add networkx, openai, sklearn, pyyaml, requests&quot;
</code></pre>
<hr />
<h2 id="phase-1-data-models-and-path-extraction">Phase 1: Data Models and Path Extraction</h2>
<h3 id="task-11-define-core-data-models">Task 1.1: Define Core Data Models</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/datamodel/types.py</code>
- Test: <code>tests/test_types.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_types.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for core data types.&quot;&quot;&quot;
from path_embedding.datamodel.types import Node, Edge, Path


def test_node_creation():
    &quot;&quot;&quot;Test creating a Node.

    &gt;&gt;&gt; node = Node(id=&quot;MESH:D001241&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;)
    &gt;&gt;&gt; node.id
    'MESH:D001241'
    &gt;&gt;&gt; node.label
    'Drug'
    &gt;&gt;&gt; node.name
    'aspirin'
    &quot;&quot;&quot;
    node = Node(id=&quot;MESH:D001241&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;)
    assert node.id == &quot;MESH:D001241&quot;
    assert node.label == &quot;Drug&quot;
    assert node.name == &quot;aspirin&quot;


def test_edge_creation():
    &quot;&quot;&quot;Test creating an Edge.

    &gt;&gt;&gt; edge = Edge(key=&quot;decreases activity of&quot;, source=&quot;MESH:D001241&quot;, target=&quot;UniProt:P00519&quot;)
    &gt;&gt;&gt; edge.key
    'decreases activity of'
    &quot;&quot;&quot;
    edge = Edge(
        key=&quot;decreases activity of&quot;,
        source=&quot;MESH:D001241&quot;,
        target=&quot;UniProt:P00519&quot;
    )
    assert edge.key == &quot;decreases activity of&quot;
    assert edge.source == &quot;MESH:D001241&quot;
    assert edge.target == &quot;UniProt:P00519&quot;


def test_path_creation():
    &quot;&quot;&quot;Test creating a Path.&quot;&quot;&quot;
    nodes = [
        Node(id=&quot;MESH:D001241&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;),
        Node(id=&quot;UniProt:P00519&quot;, label=&quot;Protein&quot;, name=&quot;COX2&quot;),
        Node(id=&quot;MESH:D010146&quot;, label=&quot;Disease&quot;, name=&quot;pain&quot;),
    ]
    edges = [
        Edge(key=&quot;inhibits&quot;, source=&quot;MESH:D001241&quot;, target=&quot;UniProt:P00519&quot;),
        Edge(key=&quot;causes&quot;, source=&quot;UniProt:P00519&quot;, target=&quot;MESH:D010146&quot;),
    ]
    path = Path(
        nodes=nodes,
        edges=edges,
        drug_id=&quot;MESH:D001241&quot;,
        disease_id=&quot;MESH:D010146&quot;,
        indication_id=&quot;test_indication_1&quot;
    )
    assert len(path.nodes) == 3
    assert len(path.edges) == 2
    assert path.drug_id == &quot;MESH:D001241&quot;
    assert path.disease_id == &quot;MESH:D010146&quot;
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_types.py -v</code></p>
<p>Expected: FAIL with "ModuleNotFoundError: No module named 'path_embedding.datamodel'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create directory: <code>mkdir -p src/path_embedding/datamodel</code></p>
<p>Create file <code>src/path_embedding/datamodel/__init__.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Data models for path embedding.&quot;&quot;&quot;
</code></pre>
<p>Create file <code>src/path_embedding/datamodel/types.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Core data types for path representation.&quot;&quot;&quot;
from dataclasses import dataclass
from typing import List


@dataclass
class Node:
    &quot;&quot;&quot;A node in a mechanistic path.

    Attributes:
        id: Unique identifier (e.g., MESH:D001241)
        label: Node type (e.g., Drug, Protein, Disease)
        name: Human-readable name (e.g., aspirin)
    &quot;&quot;&quot;
    id: str
    label: str
    name: str


@dataclass
class Edge:
    &quot;&quot;&quot;An edge in a mechanistic path.

    Attributes:
        key: Relationship type (e.g., &quot;decreases activity of&quot;)
        source: Source node ID
        target: Target node ID
    &quot;&quot;&quot;
    key: str
    source: str
    target: str


@dataclass
class Path:
    &quot;&quot;&quot;A complete mechanistic path from drug to disease.

    Attributes:
        nodes: Ordered list of nodes in the path
        edges: Ordered list of edges in the path
        drug_id: ID of the drug (start) node
        disease_id: ID of the disease (end) node
        indication_id: Original DrugMechDB indication ID
    &quot;&quot;&quot;
    nodes: List[Node]
    edges: List[Edge]
    drug_id: str
    disease_id: str
    indication_id: str
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_types.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_types.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/datamodel/ tests/test_types.py
git commit -m &quot;feat: add core data models (Node, Edge, Path)&quot;
</code></pre>
<hr />
<h3 id="task-12-drugmechdb-data-loader">Task 1.2: DrugMechDB Data Loader</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/data/__init__.py</code>
- Create: <code>src/path_embedding/data/drugmechdb.py</code>
- Test: <code>tests/test_drugmechdb.py</code>
- Create: <code>tests/data/sample_drugmechdb.yaml</code> (fixture)</p>
<p><strong>Step 1: Create test fixture</strong></p>
<p>Create file <code>tests/data/sample_drugmechdb.yaml</code>:</p>
<pre><code class="language-yaml">- _id: DB00619_MESH_D015464_1
  directed: true
  graph:
    disease: Leukemia, Myelogenous, Chronic, BCR-ABL Positive
    disease_mesh: MESH:D015464
    drug: imatinib
    drug_mesh: MESH:D000068877
    drugbank: DB00619
  links:
  - key: decreases activity of
    source: MESH:D000068877
    target: UniProt:P00519
  - key: causes
    source: UniProt:P00519
    target: MESH:D015464
  multigraph: true
  nodes:
  - id: MESH:D000068877
    label: Drug
    name: imatinib
  - id: UniProt:P00519
    label: Protein
    name: BCR/ABL
  - id: MESH:D015464
    label: Disease
    name: CML (ph+)
- _id: DB00316_MESH_D010146_1
  directed: true
  graph:
    disease: Pain
    disease_mesh: MESH:D010146
    drug: Acetaminophen
    drug_mesh: MESH:D000082
    drugbank: DB00316
  links:
  - key: decreases activity of
    source: MESH:D000082
    target: UniProt:P23219
  - key: positively regulates
    source: UniProt:P23219
    target: GO:0001516
  - key: positively regulates
    source: GO:0001516
    target: MESH:D015232
  - key: positively correlated with
    source: MESH:D015232
    target: MESH:D010146
  multigraph: true
  nodes:
  - id: MESH:D000082
    label: Drug
    name: Acetaminophen
  - id: UniProt:P23219
    label: Protein
    name: PTGS2
  - id: GO:0001516
    label: BiologicalProcess
    name: prostaglandin biosynthetic process
  - id: MESH:D015232
    label: ChemicalSubstance
    name: Dinoprostone
  - id: MESH:D010146
    label: Disease
    name: Pain
</code></pre>
<p><strong>Step 2: Write the failing test</strong></p>
<p>Create file <code>tests/test_drugmechdb.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for DrugMechDB data loading.&quot;&quot;&quot;
from pathlib import Path
from path_embedding.data.drugmechdb import load_drugmechdb


def test_load_drugmechdb():
    &quot;&quot;&quot;Test loading DrugMechDB YAML file.

    &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    &gt;&gt;&gt; len(indications)
    2
    &gt;&gt;&gt; indications[0][&quot;_id&quot;]
    'DB00619_MESH_D015464_1'
    &quot;&quot;&quot;
    test_file = &quot;tests/data/sample_drugmechdb.yaml&quot;
    indications = load_drugmechdb(test_file)

    assert len(indications) == 2
    assert indications[0][&quot;_id&quot;] == &quot;DB00619_MESH_D015464_1&quot;
    assert indications[1][&quot;_id&quot;] == &quot;DB00316_MESH_D010146_1&quot;


def test_load_drugmechdb_structure():
    &quot;&quot;&quot;Test that loaded data has correct structure.&quot;&quot;&quot;
    test_file = &quot;tests/data/sample_drugmechdb.yaml&quot;
    indications = load_drugmechdb(test_file)

    indication = indications[0]
    assert &quot;nodes&quot; in indication
    assert &quot;links&quot; in indication
    assert &quot;graph&quot; in indication
    assert indication[&quot;directed&quot;] is True
    assert indication[&quot;multigraph&quot;] is True


def test_load_drugmechdb_nodes():
    &quot;&quot;&quot;Test node structure.&quot;&quot;&quot;
    test_file = &quot;tests/data/sample_drugmechdb.yaml&quot;
    indications = load_drugmechdb(test_file)

    nodes = indications[0][&quot;nodes&quot;]
    assert len(nodes) == 3

    drug_node = nodes[0]
    assert drug_node[&quot;id&quot;] == &quot;MESH:D000068877&quot;
    assert drug_node[&quot;label&quot;] == &quot;Drug&quot;
    assert drug_node[&quot;name&quot;] == &quot;imatinib&quot;


def test_load_drugmechdb_edges():
    &quot;&quot;&quot;Test edge structure.&quot;&quot;&quot;
    test_file = &quot;tests/data/sample_drugmechdb.yaml&quot;
    indications = load_drugmechdb(test_file)

    links = indications[0][&quot;links&quot;]
    assert len(links) == 2

    edge = links[0]
    assert edge[&quot;key&quot;] == &quot;decreases activity of&quot;
    assert edge[&quot;source&quot;] == &quot;MESH:D000068877&quot;
    assert edge[&quot;target&quot;] == &quot;UniProt:P00519&quot;
</code></pre>
<p><strong>Step 3: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_drugmechdb.py -v</code></p>
<p>Expected: FAIL with "ModuleNotFoundError: No module named 'path_embedding.data'"</p>
<p><strong>Step 4: Write minimal implementation</strong></p>
<p>Create directory: <code>mkdir -p src/path_embedding/data</code></p>
<p>Create file <code>src/path_embedding/data/__init__.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Data loading and processing modules.&quot;&quot;&quot;
</code></pre>
<p>Create file <code>src/path_embedding/data/drugmechdb.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;DrugMechDB data loading utilities.&quot;&quot;&quot;
from typing import List, Dict, Any
import yaml


def load_drugmechdb(file_path: str) -&gt; List[Dict[str, Any]]:
    &quot;&quot;&quot;Load DrugMechDB YAML file.

    Args:
        file_path: Path to DrugMechDB YAML file

    Returns:
        List of indication entries (multigraphs)

    Example:
        &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
        &gt;&gt;&gt; len(indications) &gt;= 1
        True
        &gt;&gt;&gt; &quot;nodes&quot; in indications[0]
        True
    &quot;&quot;&quot;
    with open(file_path, 'r') as f:
        indications = yaml.safe_load(f)

    return indications
</code></pre>
<p><strong>Step 5: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_drugmechdb.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 6: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_drugmechdb.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 7: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/data/ tests/test_drugmechdb.py tests/data/
git commit -m &quot;feat: add DrugMechDB YAML loader&quot;
</code></pre>
<hr />
<h3 id="task-13-networkx-multigraph-construction">Task 1.3: NetworkX Multigraph Construction</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/utils/__init__.py</code>
- Create: <code>src/path_embedding/utils/path_extraction.py</code>
- Test: <code>tests/test_path_extraction.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_path_extraction.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for path extraction from multigraphs.&quot;&quot;&quot;
import networkx as nx
from path_embedding.utils.path_extraction import build_multigraph, find_drug_disease_nodes
from path_embedding.data.drugmechdb import load_drugmechdb


def test_build_multigraph():
    &quot;&quot;&quot;Test building NetworkX multigraph from indication.

    &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    &gt;&gt;&gt; graph = build_multigraph(indications[0])
    &gt;&gt;&gt; isinstance(graph, nx.MultiDiGraph)
    True
    &gt;&gt;&gt; graph.number_of_nodes()
    3
    &gt;&gt;&gt; graph.number_of_edges()
    2
    &quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    indication = indications[0]

    graph = build_multigraph(indication)

    assert isinstance(graph, nx.MultiDiGraph)
    assert graph.number_of_nodes() == 3
    assert graph.number_of_edges() == 2


def test_build_multigraph_node_attributes():
    &quot;&quot;&quot;Test that nodes have correct attributes.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    graph = build_multigraph(indications[0])

    # Check drug node
    drug_id = &quot;MESH:D000068877&quot;
    assert drug_id in graph.nodes
    assert graph.nodes[drug_id][&quot;label&quot;] == &quot;Drug&quot;
    assert graph.nodes[drug_id][&quot;name&quot;] == &quot;imatinib&quot;


def test_build_multigraph_edge_attributes():
    &quot;&quot;&quot;Test that edges have correct attributes.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    graph = build_multigraph(indications[0])

    # Check edge
    edges = list(graph.edges(data=True, keys=True))
    source, target, key, data = edges[0]

    assert data[&quot;key&quot;] == &quot;decreases activity of&quot;


def test_find_drug_disease_nodes():
    &quot;&quot;&quot;Test finding drug and disease nodes in graph.

    &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    &gt;&gt;&gt; graph = build_multigraph(indications[0])
    &gt;&gt;&gt; drug_id, disease_id = find_drug_disease_nodes(graph)
    &gt;&gt;&gt; drug_id
    'MESH:D000068877'
    &gt;&gt;&gt; disease_id
    'MESH:D015464'
    &quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    graph = build_multigraph(indications[0])

    drug_id, disease_id = find_drug_disease_nodes(graph)

    assert drug_id == &quot;MESH:D000068877&quot;
    assert disease_id == &quot;MESH:D015464&quot;
    assert graph.nodes[drug_id][&quot;label&quot;] == &quot;Drug&quot;
    assert graph.nodes[disease_id][&quot;label&quot;] == &quot;Disease&quot;


def test_find_drug_disease_nodes_second_example():
    &quot;&quot;&quot;Test with second example (multiple intermediate nodes).&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    graph = build_multigraph(indications[1])

    drug_id, disease_id = find_drug_disease_nodes(graph)

    assert graph.nodes[drug_id][&quot;label&quot;] == &quot;Drug&quot;
    assert graph.nodes[disease_id][&quot;label&quot;] == &quot;Disease&quot;
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_path_extraction.py -v</code></p>
<p>Expected: FAIL with "ModuleNotFoundError: No module named 'path_embedding.utils'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create directory: <code>mkdir -p src/path_embedding/utils</code></p>
<p>Create file <code>src/path_embedding/utils/__init__.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Utility modules.&quot;&quot;&quot;
</code></pre>
<p>Create file <code>src/path_embedding/utils/path_extraction.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Path extraction from NetworkX multigraphs.&quot;&quot;&quot;
from typing import Dict, Any, Tuple
import networkx as nx


def build_multigraph(indication: Dict[str, Any]) -&gt; nx.MultiDiGraph:
    &quot;&quot;&quot;Build NetworkX MultiDiGraph from DrugMechDB indication.

    Args:
        indication: DrugMechDB indication entry with nodes and links

    Returns:
        NetworkX MultiDiGraph with nodes and edges

    Example:
        &gt;&gt;&gt; from path_embedding.data.drugmechdb import load_drugmechdb
        &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
        &gt;&gt;&gt; graph = build_multigraph(indications[0])
        &gt;&gt;&gt; graph.number_of_nodes() &gt;= 3
        True
    &quot;&quot;&quot;
    graph = nx.MultiDiGraph()

    # Add nodes with attributes
    for node in indication[&quot;nodes&quot;]:
        graph.add_node(
            node[&quot;id&quot;],
            label=node[&quot;label&quot;],
            name=node[&quot;name&quot;]
        )

    # Add edges with attributes
    for link in indication[&quot;links&quot;]:
        graph.add_edge(
            link[&quot;source&quot;],
            link[&quot;target&quot;],
            key=link[&quot;key&quot;]
        )

    return graph


def find_drug_disease_nodes(graph: nx.MultiDiGraph) -&gt; Tuple[str, str]:
    &quot;&quot;&quot;Find drug and disease node IDs in graph.

    Args:
        graph: NetworkX MultiDiGraph with labeled nodes

    Returns:
        Tuple of (drug_id, disease_id)

    Raises:
        ValueError: If drug or disease node not found

    Example:
        &gt;&gt;&gt; from path_embedding.data.drugmechdb import load_drugmechdb
        &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
        &gt;&gt;&gt; graph = build_multigraph(indications[0])
        &gt;&gt;&gt; drug_id, disease_id = find_drug_disease_nodes(graph)
        &gt;&gt;&gt; isinstance(drug_id, str) and isinstance(disease_id, str)
        True
    &quot;&quot;&quot;
    drug_id = None
    disease_id = None

    for node_id, attrs in graph.nodes(data=True):
        if attrs[&quot;label&quot;] == &quot;Drug&quot;:
            drug_id = node_id
        elif attrs[&quot;label&quot;] == &quot;Disease&quot;:
            disease_id = node_id

    if drug_id is None:
        raise ValueError(&quot;No Drug node found in graph&quot;)
    if disease_id is None:
        raise ValueError(&quot;No Disease node found in graph&quot;)

    return drug_id, disease_id
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_path_extraction.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_path_extraction.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/utils/ tests/test_path_extraction.py
git commit -m &quot;feat: add NetworkX multigraph construction&quot;
</code></pre>
<hr />
<h3 id="task-14-extract-paths-from-multigraph">Task 1.4: Extract Paths from Multigraph</h3>
<p><strong>Files:</strong>
- Modify: <code>src/path_embedding/utils/path_extraction.py</code>
- Modify: <code>tests/test_path_extraction.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Add to <code>tests/test_path_extraction.py</code>:</p>
<pre><code class="language-python">from path_embedding.utils.path_extraction import extract_paths
from path_embedding.datamodel.types import Path


def test_extract_paths_simple():
    &quot;&quot;&quot;Test extracting paths from simple graph.

    &gt;&gt;&gt; from path_embedding.data.drugmechdb import load_drugmechdb
    &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    &gt;&gt;&gt; graph = build_multigraph(indications[0])
    &gt;&gt;&gt; paths = extract_paths(graph, &quot;DB00619_MESH_D015464_1&quot;)
    &gt;&gt;&gt; len(paths)
    1
    &gt;&gt;&gt; isinstance(paths[0], Path)
    True
    &quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    indication = indications[0]
    graph = build_multigraph(indication)

    paths = extract_paths(graph, indication[&quot;_id&quot;])

    assert len(paths) == 1
    assert isinstance(paths[0], Path)


def test_extract_paths_structure():
    &quot;&quot;&quot;Test that extracted path has correct structure.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    indication = indications[0]
    graph = build_multigraph(indication)

    paths = extract_paths(graph, indication[&quot;_id&quot;])
    path = paths[0]

    # Should have 3 nodes: Drug -&gt; Protein -&gt; Disease
    assert len(path.nodes) == 3
    # Should have 2 edges
    assert len(path.edges) == 2

    # Check drug and disease
    assert path.drug_id == &quot;MESH:D000068877&quot;
    assert path.disease_id == &quot;MESH:D015464&quot;
    assert path.indication_id == &quot;DB00619_MESH_D015464_1&quot;

    # Check node order
    assert path.nodes[0].label == &quot;Drug&quot;
    assert path.nodes[1].label == &quot;Protein&quot;
    assert path.nodes[2].label == &quot;Disease&quot;


def test_extract_paths_multiple():
    &quot;&quot;&quot;Test extracting multiple paths.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    indication = indications[1]  # Second example has longer path
    graph = build_multigraph(indication)

    paths = extract_paths(graph, indication[&quot;_id&quot;])

    # Should extract at least one path
    assert len(paths) &gt;= 1

    # All paths should start with Drug and end with Disease
    for path in paths:
        assert path.nodes[0].label == &quot;Drug&quot;
        assert path.nodes[-1].label == &quot;Disease&quot;


def test_extract_paths_max_limit():
    &quot;&quot;&quot;Test limiting number of paths extracted.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    indication = indications[0]
    graph = build_multigraph(indication)

    # Extract with limit
    paths = extract_paths(graph, indication[&quot;_id&quot;], max_paths=1)

    assert len(paths) &lt;= 1
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_path_extraction.py::test_extract_paths_simple -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'extract_paths'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Add to <code>src/path_embedding/utils/path_extraction.py</code>:</p>
<pre><code class="language-python">from typing import List
from path_embedding.datamodel.types import Node, Edge, Path
import random


def extract_paths(
    graph: nx.MultiDiGraph,
    indication_id: str,
    max_paths: int = 10
) -&gt; List[Path]:
    &quot;&quot;&quot;Extract all simple paths from drug to disease in multigraph.

    Args:
        graph: NetworkX MultiDiGraph
        indication_id: Original DrugMechDB indication ID
        max_paths: Maximum number of paths to extract (randomly sample if more)

    Returns:
        List of Path objects

    Example:
        &gt;&gt;&gt; from path_embedding.data.drugmechdb import load_drugmechdb
        &gt;&gt;&gt; indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
        &gt;&gt;&gt; graph = build_multigraph(indications[0])
        &gt;&gt;&gt; paths = extract_paths(graph, indications[0][&quot;_id&quot;])
        &gt;&gt;&gt; len(paths) &gt;= 1
        True
    &quot;&quot;&quot;
    # Find drug and disease nodes
    drug_id, disease_id = find_drug_disease_nodes(graph)

    # Extract all simple paths
    all_node_paths = list(nx.all_simple_paths(graph, drug_id, disease_id))

    # Sample if too many paths
    if len(all_node_paths) &gt; max_paths:
        all_node_paths = random.sample(all_node_paths, max_paths)

    # Convert to Path objects
    paths = []
    for node_path in all_node_paths:
        # Build nodes list
        nodes = []
        for node_id in node_path:
            node_data = graph.nodes[node_id]
            nodes.append(Node(
                id=node_id,
                label=node_data[&quot;label&quot;],
                name=node_data[&quot;name&quot;]
            ))

        # Build edges list
        edges = []
        for i in range(len(node_path) - 1):
            source = node_path[i]
            target = node_path[i + 1]

            # Get edge data (handle multigraph - may have multiple edges)
            edge_data = graph.get_edge_data(source, target)
            # Take first edge if multiple exist
            edge_key = list(edge_data.keys())[0]
            edge_attrs = edge_data[edge_key]

            edges.append(Edge(
                key=edge_attrs[&quot;key&quot;],
                source=source,
                target=target
            ))

        paths.append(Path(
            nodes=nodes,
            edges=edges,
            drug_id=drug_id,
            disease_id=disease_id,
            indication_id=indication_id
        ))

    return paths
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_path_extraction.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_path_extraction.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/utils/path_extraction.py tests/test_path_extraction.py
git commit -m &quot;feat: add path extraction from multigraphs&quot;
</code></pre>
<hr />
<h2 id="phase-2-text-formatting">Phase 2: Text Formatting</h2>
<h3 id="task-21-path-to-text-conversion">Task 2.1: Path to Text Conversion</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/embedding/__init__.py</code>
- Create: <code>src/path_embedding/embedding/text_formatter.py</code>
- Test: <code>tests/test_text_formatter.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_text_formatter.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for path to text conversion.&quot;&quot;&quot;
from path_embedding.embedding.text_formatter import path_to_text
from path_embedding.datamodel.types import Node, Edge, Path


def test_path_to_text_simple():
    &quot;&quot;&quot;Test converting simple path to text.

    &gt;&gt;&gt; nodes = [
    ...     Node(id=&quot;MESH:D001241&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;),
    ...     Node(id=&quot;UniProt:P00519&quot;, label=&quot;Protein&quot;, name=&quot;COX2&quot;),
    ...     Node(id=&quot;MESH:D010146&quot;, label=&quot;Disease&quot;, name=&quot;pain&quot;)
    ... ]
    &gt;&gt;&gt; edges = [
    ...     Edge(key=&quot;inhibits&quot;, source=&quot;MESH:D001241&quot;, target=&quot;UniProt:P00519&quot;),
    ...     Edge(key=&quot;causes&quot;, source=&quot;UniProt:P00519&quot;, target=&quot;MESH:D010146&quot;)
    ... ]
    &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;MESH:D001241&quot;,
    ...             disease_id=&quot;MESH:D010146&quot;, indication_id=&quot;test&quot;)
    &gt;&gt;&gt; text = path_to_text(path)
    &gt;&gt;&gt; text
    'Drug: aspirin | inhibits | Protein: COX2 | causes | Disease: pain'
    &quot;&quot;&quot;
    nodes = [
        Node(id=&quot;MESH:D001241&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;),
        Node(id=&quot;UniProt:P00519&quot;, label=&quot;Protein&quot;, name=&quot;COX2&quot;),
        Node(id=&quot;MESH:D010146&quot;, label=&quot;Disease&quot;, name=&quot;pain&quot;),
    ]
    edges = [
        Edge(key=&quot;inhibits&quot;, source=&quot;MESH:D001241&quot;, target=&quot;UniProt:P00519&quot;),
        Edge(key=&quot;causes&quot;, source=&quot;UniProt:P00519&quot;, target=&quot;MESH:D010146&quot;),
    ]
    path = Path(
        nodes=nodes,
        edges=edges,
        drug_id=&quot;MESH:D001241&quot;,
        disease_id=&quot;MESH:D010146&quot;,
        indication_id=&quot;test_1&quot;
    )

    text = path_to_text(path)

    expected = &quot;Drug: aspirin | inhibits | Protein: COX2 | causes | Disease: pain&quot;
    assert text == expected


def test_path_to_text_real_example():
    &quot;&quot;&quot;Test with real DrugMechDB example.&quot;&quot;&quot;
    from path_embedding.data.drugmechdb import load_drugmechdb
    from path_embedding.utils.path_extraction import build_multigraph, extract_paths

    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    graph = build_multigraph(indications[0])
    paths = extract_paths(graph, indications[0][&quot;_id&quot;])

    text = path_to_text(paths[0])

    # Should contain all components
    assert &quot;Drug:&quot; in text
    assert &quot;Protein:&quot; in text
    assert &quot;Disease:&quot; in text
    assert &quot;|&quot; in text
    assert &quot;decreases activity of&quot; in text or &quot;causes&quot; in text


def test_path_to_text_format():
    &quot;&quot;&quot;Test text format structure.&quot;&quot;&quot;
    nodes = [
        Node(id=&quot;A&quot;, label=&quot;Drug&quot;, name=&quot;drugA&quot;),
        Node(id=&quot;B&quot;, label=&quot;Gene&quot;, name=&quot;geneB&quot;),
        Node(id=&quot;C&quot;, label=&quot;Disease&quot;, name=&quot;diseaseC&quot;),
    ]
    edges = [
        Edge(key=&quot;regulates&quot;, source=&quot;A&quot;, target=&quot;B&quot;),
        Edge(key=&quot;affects&quot;, source=&quot;B&quot;, target=&quot;C&quot;),
    ]
    path = Path(
        nodes=nodes, edges=edges,
        drug_id=&quot;A&quot;, disease_id=&quot;C&quot;, indication_id=&quot;test&quot;
    )

    text = path_to_text(path)

    # Check format: Node | Edge | Node | Edge | Node
    parts = [p.strip() for p in text.split(&quot;|&quot;)]
    assert len(parts) == 5
    assert parts[0].startswith(&quot;Drug:&quot;)
    assert parts[2].startswith(&quot;Gene:&quot;)
    assert parts[4].startswith(&quot;Disease:&quot;)
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_text_formatter.py -v</code></p>
<p>Expected: FAIL with "ModuleNotFoundError: No module named 'path_embedding.embedding'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create directory: <code>mkdir -p src/path_embedding/embedding</code></p>
<p>Create file <code>src/path_embedding/embedding/__init__.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Embedding generation modules.&quot;&quot;&quot;
</code></pre>
<p>Create file <code>src/path_embedding/embedding/text_formatter.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Convert paths to structured text representations.&quot;&quot;&quot;
from path_embedding.datamodel.types import Path


def path_to_text(path: Path) -&gt; str:
    &quot;&quot;&quot;Convert a Path object to structured text format.

    Format: {label}: {name} | {edge_key} | {label}: {name} | ...

    Args:
        path: Path object to convert

    Returns:
        Structured text representation

    Example:
        &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
        &gt;&gt;&gt; nodes = [
        ...     Node(id=&quot;A&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;),
        ...     Node(id=&quot;B&quot;, label=&quot;Protein&quot;, name=&quot;COX2&quot;),
        ...     Node(id=&quot;C&quot;, label=&quot;Disease&quot;, name=&quot;pain&quot;)
        ... ]
        &gt;&gt;&gt; edges = [
        ...     Edge(key=&quot;inhibits&quot;, source=&quot;A&quot;, target=&quot;B&quot;),
        ...     Edge(key=&quot;causes&quot;, source=&quot;B&quot;, target=&quot;C&quot;)
        ... ]
        &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;A&quot;,
        ...             disease_id=&quot;C&quot;, indication_id=&quot;test&quot;)
        &gt;&gt;&gt; path_to_text(path)
        'Drug: aspirin | inhibits | Protein: COX2 | causes | Disease: pain'
    &quot;&quot;&quot;
    parts = []

    for i, node in enumerate(path.nodes):
        # Add node
        parts.append(f&quot;{node.label}: {node.name}&quot;)

        # Add edge if not last node
        if i &lt; len(path.edges):
            parts.append(path.edges[i].key)

    return &quot; | &quot;.join(parts)
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_text_formatter.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_text_formatter.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/embedding/ tests/test_text_formatter.py
git commit -m &quot;feat: add path to text conversion&quot;
</code></pre>
<hr />
<h2 id="phase-3-negative-sampling">Phase 3: Negative Sampling</h2>
<h3 id="task-31-build-node-inventory">Task 3.1: Build Node Inventory</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/data/negative_sampling.py</code>
- Test: <code>tests/test_negative_sampling.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_negative_sampling.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for negative example generation.&quot;&quot;&quot;
from path_embedding.data.negative_sampling import build_node_inventory
from path_embedding.data.drugmechdb import load_drugmechdb
from path_embedding.utils.path_extraction import build_multigraph, extract_paths


def test_build_node_inventory():
    &quot;&quot;&quot;Test building node inventory grouped by type and disease.

    &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Path
    &gt;&gt;&gt; nodes1 = [
    ...     Node(id=&quot;D1&quot;, label=&quot;Drug&quot;, name=&quot;drug1&quot;),
    ...     Node(id=&quot;G1&quot;, label=&quot;Gene&quot;, name=&quot;gene1&quot;),
    ...     Node(id=&quot;DIS1&quot;, label=&quot;Disease&quot;, name=&quot;disease1&quot;)
    ... ]
    &gt;&gt;&gt; path1 = Path(nodes=nodes1, edges=[], drug_id=&quot;D1&quot;,
    ...              disease_id=&quot;DIS1&quot;, indication_id=&quot;ind1&quot;)
    &gt;&gt;&gt; inventory = build_node_inventory([path1])
    &gt;&gt;&gt; &quot;Gene&quot; in inventory
    True
    &quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)

    # Extract all paths
    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    inventory = build_node_inventory(all_paths)

    # Should have node types as keys
    assert isinstance(inventory, dict)
    assert &quot;Protein&quot; in inventory or &quot;BiologicalProcess&quot; in inventory

    # Each node type should map to disease -&gt; nodes
    for node_type, disease_dict in inventory.items():
        assert isinstance(disease_dict, dict)


def test_build_node_inventory_structure():
    &quot;&quot;&quot;Test inventory structure: {node_type: {disease_id: [nodes]}}.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    inventory = build_node_inventory(all_paths)

    # Check structure
    for node_type, disease_dict in inventory.items():
        for disease_id, nodes in disease_dict.items():
            assert isinstance(nodes, list)
            assert len(nodes) &gt; 0
            # All nodes should have the expected type
            for node in nodes:
                assert node.label == node_type


def test_build_node_inventory_excludes_drug_disease():
    &quot;&quot;&quot;Test that Drug and Disease nodes are excluded from inventory.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    inventory = build_node_inventory(all_paths)

    # Should not include Drug or Disease in inventory
    assert &quot;Drug&quot; not in inventory
    assert &quot;Disease&quot; not in inventory
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py::test_build_node_inventory -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'build_node_inventory'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create file <code>src/path_embedding/data/negative_sampling.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Generate negative examples via cross-disease shuffling.&quot;&quot;&quot;
from typing import List, Dict
from collections import defaultdict
from path_embedding.datamodel.types import Path, Node


def build_node_inventory(paths: List[Path]) -&gt; Dict[str, Dict[str, List[Node]]]:
    &quot;&quot;&quot;Build inventory of nodes grouped by type and disease context.

    Structure: {node_type: {disease_id: [nodes]}}
    Excludes Drug and Disease nodes (only intermediate nodes).

    Args:
        paths: List of Path objects

    Returns:
        Nested dict mapping node_type -&gt; disease_id -&gt; list of nodes

    Example:
        &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Path
        &gt;&gt;&gt; nodes = [
        ...     Node(id=&quot;D1&quot;, label=&quot;Drug&quot;, name=&quot;drug1&quot;),
        ...     Node(id=&quot;G1&quot;, label=&quot;Gene&quot;, name=&quot;gene1&quot;),
        ...     Node(id=&quot;DIS1&quot;, label=&quot;Disease&quot;, name=&quot;disease1&quot;)
        ... ]
        &gt;&gt;&gt; path = Path(nodes=nodes, edges=[], drug_id=&quot;D1&quot;,
        ...             disease_id=&quot;DIS1&quot;, indication_id=&quot;ind1&quot;)
        &gt;&gt;&gt; inventory = build_node_inventory([path])
        &gt;&gt;&gt; &quot;Gene&quot; in inventory
        True
        &gt;&gt;&gt; &quot;Drug&quot; not in inventory
        True
    &quot;&quot;&quot;
    inventory = defaultdict(lambda: defaultdict(list))

    for path in paths:
        # Get disease context from this path
        disease_id = path.disease_id

        # Add all intermediate nodes (exclude Drug and Disease)
        for node in path.nodes:
            if node.label not in [&quot;Drug&quot;, &quot;Disease&quot;]:
                # Add to inventory: node_type -&gt; disease_id -&gt; nodes
                inventory[node.label][disease_id].append(node)

    # Convert to regular dict
    return {k: dict(v) for k, v in inventory.items()}
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/data/negative_sampling.py tests/test_negative_sampling.py
git commit -m &quot;feat: add node inventory builder for negative sampling&quot;
</code></pre>
<hr />
<h3 id="task-32-generate-negative-path">Task 3.2: Generate Negative Path</h3>
<p><strong>Files:</strong>
- Modify: <code>src/path_embedding/data/negative_sampling.py</code>
- Modify: <code>tests/test_negative_sampling.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Add to <code>tests/test_negative_sampling.py</code>:</p>
<pre><code class="language-python">from path_embedding.data.negative_sampling import generate_negative_path
import random


def test_generate_negative_path():
    &quot;&quot;&quot;Test generating negative path from positive.

    &gt;&gt;&gt; random.seed(42)
    &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
    &gt;&gt;&gt; nodes = [
    ...     Node(id=&quot;D1&quot;, label=&quot;Drug&quot;, name=&quot;drug1&quot;),
    ...     Node(id=&quot;G1&quot;, label=&quot;Gene&quot;, name=&quot;gene1&quot;),
    ...     Node(id=&quot;DIS1&quot;, label=&quot;Disease&quot;, name=&quot;disease1&quot;)
    ... ]
    &gt;&gt;&gt; edges = [
    ...     Edge(key=&quot;regulates&quot;, source=&quot;D1&quot;, target=&quot;G1&quot;),
    ...     Edge(key=&quot;causes&quot;, source=&quot;G1&quot;, target=&quot;DIS1&quot;)
    ... ]
    &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;D1&quot;,
    ...             disease_id=&quot;DIS1&quot;, indication_id=&quot;ind1&quot;)
    &gt;&gt;&gt; inventory = {&quot;Gene&quot;: {&quot;DIS2&quot;: [Node(id=&quot;G2&quot;, label=&quot;Gene&quot;, name=&quot;gene2&quot;)]}}
    &gt;&gt;&gt; neg_path = generate_negative_path(path, inventory)
    &gt;&gt;&gt; neg_path.nodes[0].id == &quot;D1&quot;  # Same drug
    True
    &gt;&gt;&gt; neg_path.nodes[-1].id == &quot;DIS1&quot;  # Same disease
    True
    &quot;&quot;&quot;
    random.seed(42)

    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    inventory = build_node_inventory(all_paths)
    positive_path = all_paths[0]

    negative_path = generate_negative_path(positive_path, inventory)

    # Should preserve drug and disease
    assert negative_path.drug_id == positive_path.drug_id
    assert negative_path.disease_id == positive_path.disease_id

    # Should have same number of nodes
    assert len(negative_path.nodes) == len(positive_path.nodes)

    # First and last nodes should be same
    assert negative_path.nodes[0].id == positive_path.nodes[0].id
    assert negative_path.nodes[-1].id == positive_path.nodes[-1].id


def test_generate_negative_path_preserves_types():
    &quot;&quot;&quot;Test that negative path preserves node types.&quot;&quot;&quot;
    random.seed(42)

    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    inventory = build_node_inventory(all_paths)

    # Use second example which has more intermediate nodes
    positive_path = all_paths[1] if len(all_paths) &gt; 1 else all_paths[0]
    negative_path = generate_negative_path(positive_path, inventory)

    # Check that node types match in order
    for i, (pos_node, neg_node) in enumerate(zip(positive_path.nodes, negative_path.nodes)):
        assert pos_node.label == neg_node.label, f&quot;Node {i} type mismatch&quot;


def test_generate_negative_path_different_disease_context():
    &quot;&quot;&quot;Test that intermediate nodes come from different disease context.&quot;&quot;&quot;
    random.seed(42)

    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)

    # Need at least 2 different diseases
    if len(indications) &lt; 2:
        return  # Skip if not enough data

    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    inventory = build_node_inventory(all_paths)
    positive_path = all_paths[0]

    negative_path = generate_negative_path(positive_path, inventory)

    # At least one intermediate node should be different
    # (if we have enough diversity in the data)
    intermediate_changed = False
    for i in range(1, len(positive_path.nodes) - 1):
        if positive_path.nodes[i].id != negative_path.nodes[i].id:
            intermediate_changed = True
            break

    # If we have multiple diseases, should have changed something
    if len(indications) &gt;= 2:
        assert intermediate_changed
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py::test_generate_negative_path -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'generate_negative_path'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Add to <code>src/path_embedding/data/negative_sampling.py</code>:</p>
<pre><code class="language-python">import random
from path_embedding.datamodel.types import Edge


def generate_negative_path(
    positive_path: Path,
    node_inventory: Dict[str, Dict[str, List[Node]]]
) -&gt; Path:
    &quot;&quot;&quot;Generate negative path via cross-disease shuffling with type matching.

    Keep drug and disease nodes. For each intermediate node, replace with
    a random node of the same type from a different disease context.

    Args:
        positive_path: Original positive Path
        node_inventory: Inventory from build_node_inventory()

    Returns:
        Negative Path with shuffled intermediate nodes

    Example:
        &gt;&gt;&gt; random.seed(42)
        &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
        &gt;&gt;&gt; nodes = [
        ...     Node(id=&quot;D1&quot;, label=&quot;Drug&quot;, name=&quot;drug1&quot;),
        ...     Node(id=&quot;G1&quot;, label=&quot;Gene&quot;, name=&quot;gene1&quot;),
        ...     Node(id=&quot;DIS1&quot;, label=&quot;Disease&quot;, name=&quot;disease1&quot;)
        ... ]
        &gt;&gt;&gt; edges = [
        ...     Edge(key=&quot;reg&quot;, source=&quot;D1&quot;, target=&quot;G1&quot;),
        ...     Edge(key=&quot;causes&quot;, source=&quot;G1&quot;, target=&quot;DIS1&quot;)
        ... ]
        &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;D1&quot;,
        ...             disease_id=&quot;DIS1&quot;, indication_id=&quot;ind1&quot;)
        &gt;&gt;&gt; inv = {&quot;Gene&quot;: {&quot;DIS2&quot;: [Node(id=&quot;G2&quot;, label=&quot;Gene&quot;, name=&quot;gene2&quot;)]}}
        &gt;&gt;&gt; neg = generate_negative_path(path, inv)
        &gt;&gt;&gt; neg.nodes[0].id == &quot;D1&quot;  # Same drug
        True
    &quot;&quot;&quot;
    new_nodes = []

    for i, node in enumerate(positive_path.nodes):
        # Keep drug and disease
        if node.label in [&quot;Drug&quot;, &quot;Disease&quot;]:
            new_nodes.append(node)
        else:
            # Replace with random node of same type from different disease
            node_type = node.label

            if node_type in node_inventory:
                # Get all disease contexts for this node type
                disease_dict = node_inventory[node_type]

                # Exclude current disease context
                other_diseases = [
                    disease_id for disease_id in disease_dict.keys()
                    if disease_id != positive_path.disease_id
                ]

                if other_diseases:
                    # Pick random disease context
                    random_disease = random.choice(other_diseases)
                    # Pick random node from that context
                    random_node = random.choice(disease_dict[random_disease])
                    new_nodes.append(random_node)
                else:
                    # No other disease context, keep original
                    new_nodes.append(node)
            else:
                # Node type not in inventory, keep original
                new_nodes.append(node)

    # Build new edges with updated source/target IDs
    new_edges = []
    for i, edge in enumerate(positive_path.edges):
        new_edges.append(Edge(
            key=edge.key,
            source=new_nodes[i].id,
            target=new_nodes[i + 1].id
        ))

    # Create negative path
    negative_path = Path(
        nodes=new_nodes,
        edges=new_edges,
        drug_id=positive_path.drug_id,
        disease_id=positive_path.disease_id,
        indication_id=f&quot;{positive_path.indication_id}_negative&quot;
    )

    return negative_path
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/data/negative_sampling.py tests/test_negative_sampling.py
git commit -m &quot;feat: add negative path generation via cross-disease shuffling&quot;
</code></pre>
<hr />
<h3 id="task-33-generate-full-negative-dataset">Task 3.3: Generate Full Negative Dataset</h3>
<p><strong>Files:</strong>
- Modify: <code>src/path_embedding/data/negative_sampling.py</code>
- Modify: <code>tests/test_negative_sampling.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Add to <code>tests/test_negative_sampling.py</code>:</p>
<pre><code class="language-python">from path_embedding.data.negative_sampling import generate_negatives


def test_generate_negatives():
    &quot;&quot;&quot;Test generating negative dataset.

    &gt;&gt;&gt; random.seed(42)
    &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
    &gt;&gt;&gt; nodes = [
    ...     Node(id=&quot;D1&quot;, label=&quot;Drug&quot;, name=&quot;drug1&quot;),
    ...     Node(id=&quot;G1&quot;, label=&quot;Gene&quot;, name=&quot;gene1&quot;),
    ...     Node(id=&quot;DIS1&quot;, label=&quot;Disease&quot;, name=&quot;disease1&quot;)
    ... ]
    &gt;&gt;&gt; edges = [Edge(key=&quot;reg&quot;, source=&quot;D1&quot;, target=&quot;G1&quot;),
    ...          Edge(key=&quot;causes&quot;, source=&quot;G1&quot;, target=&quot;DIS1&quot;)]
    &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;D1&quot;,
    ...             disease_id=&quot;DIS1&quot;, indication_id=&quot;ind1&quot;)
    &gt;&gt;&gt; negs = generate_negatives([path])
    &gt;&gt;&gt; len(negs) == 1
    True
    &quot;&quot;&quot;
    random.seed(42)

    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    negatives = generate_negatives(all_paths)

    # Should have 1:1 ratio
    assert len(negatives) == len(all_paths)

    # Each negative should be valid Path
    for neg in negatives:
        assert isinstance(neg, Path)
        assert len(neg.nodes) &gt; 0
        assert neg.nodes[0].label == &quot;Drug&quot;
        assert neg.nodes[-1].label == &quot;Disease&quot;
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py::test_generate_negatives -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'generate_negatives'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Add to <code>src/path_embedding/data/negative_sampling.py</code>:</p>
<pre><code class="language-python">def generate_negatives(positive_paths: List[Path]) -&gt; List[Path]:
    &quot;&quot;&quot;Generate negative examples for all positive paths.

    Creates 1:1 ratio of positives to negatives using cross-disease shuffling.

    Args:
        positive_paths: List of positive Path objects

    Returns:
        List of negative Path objects (same length as input)

    Example:
        &gt;&gt;&gt; random.seed(42)
        &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
        &gt;&gt;&gt; nodes = [
        ...     Node(id=&quot;D1&quot;, label=&quot;Drug&quot;, name=&quot;d1&quot;),
        ...     Node(id=&quot;G1&quot;, label=&quot;Gene&quot;, name=&quot;g1&quot;),
        ...     Node(id=&quot;DIS1&quot;, label=&quot;Disease&quot;, name=&quot;dis1&quot;)
        ... ]
        &gt;&gt;&gt; edges = [Edge(key=&quot;r&quot;, source=&quot;D1&quot;, target=&quot;G1&quot;),
        ...          Edge(key=&quot;c&quot;, source=&quot;G1&quot;, target=&quot;DIS1&quot;)]
        &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;D1&quot;,
        ...             disease_id=&quot;DIS1&quot;, indication_id=&quot;i1&quot;)
        &gt;&gt;&gt; negs = generate_negatives([path])
        &gt;&gt;&gt; len(negs)
        1
    &quot;&quot;&quot;
    # Build node inventory from all positive paths
    inventory = build_node_inventory(positive_paths)

    # Generate one negative for each positive
    negatives = []
    for positive_path in positive_paths:
        negative_path = generate_negative_path(positive_path, inventory)
        negatives.append(negative_path)

    return negatives
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_negative_sampling.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/data/negative_sampling.py tests/test_negative_sampling.py
git commit -m &quot;feat: add full negative dataset generation&quot;
</code></pre>
<hr />
<h2 id="phase-4-openai-embeddings">Phase 4: OpenAI Embeddings</h2>
<h3 id="task-41-openai-api-integration">Task 4.1: OpenAI API Integration</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/embedding/openai_embedder.py</code>
- Test: <code>tests/test_openai_embedder.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_openai_embedder.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for OpenAI embedding generation.&quot;&quot;&quot;
import numpy as np
from path_embedding.embedding.openai_embedder import load_api_key, embed_text


def test_load_api_key():
    &quot;&quot;&quot;Test loading API key from file.

    &gt;&gt;&gt; key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)
    &gt;&gt;&gt; len(key) &gt; 0
    True
    &gt;&gt;&gt; key.startswith(&quot;sk-&quot;)
    True
    &quot;&quot;&quot;
    key_path = &quot;/Users/jtr4v/openai.key.another&quot;
    key = load_api_key(key_path)

    assert isinstance(key, str)
    assert len(key) &gt; 0
    # OpenAI keys start with &quot;sk-&quot;
    assert key.startswith(&quot;sk-&quot;)


def test_embed_text():
    &quot;&quot;&quot;Test embedding simple text with OpenAI API.

    Note: This test makes real API call and may be slow.
    &quot;&quot;&quot;
    key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)
    text = &quot;Drug: aspirin | inhibits | Protein: COX2&quot;

    embedding = embed_text(text, key)

    assert isinstance(embedding, np.ndarray)
    assert len(embedding.shape) == 1  # 1D array
    assert embedding.shape[0] &gt; 0  # Has dimensions
    # text-embedding-3-small has 1536 dimensions
    assert embedding.shape[0] == 1536


def test_embed_text_different_inputs():
    &quot;&quot;&quot;Test that different texts produce different embeddings.&quot;&quot;&quot;
    key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)

    text1 = &quot;Drug: aspirin | inhibits | Protein: COX2&quot;
    text2 = &quot;Drug: imatinib | decreases activity of | Protein: BCR/ABL&quot;

    emb1 = embed_text(text1, key)
    emb2 = embed_text(text2, key)

    # Embeddings should be different
    assert not np.array_equal(emb1, emb2)
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py::test_load_api_key -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'load_api_key'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create file <code>src/path_embedding/embedding/openai_embedder.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;OpenAI embedding generation.&quot;&quot;&quot;
import numpy as np
from openai import OpenAI


def load_api_key(key_path: str) -&gt; str:
    &quot;&quot;&quot;Load OpenAI API key from file.

    Args:
        key_path: Path to file containing API key

    Returns:
        API key as string

    Example:
        &gt;&gt;&gt; key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)
        &gt;&gt;&gt; len(key) &gt; 0
        True
    &quot;&quot;&quot;
    with open(key_path, 'r') as f:
        api_key = f.read().strip()
    return api_key


def embed_text(text: str, api_key: str, model: str = &quot;text-embedding-3-small&quot;) -&gt; np.ndarray:
    &quot;&quot;&quot;Generate embedding for text using OpenAI API.

    Args:
        text: Text to embed
        api_key: OpenAI API key
        model: OpenAI embedding model (default: text-embedding-3-small)

    Returns:
        Embedding vector as numpy array

    Example:
        &gt;&gt;&gt; key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)
        &gt;&gt;&gt; emb = embed_text(&quot;test text&quot;, key)
        &gt;&gt;&gt; isinstance(emb, np.ndarray)
        True
    &quot;&quot;&quot;
    client = OpenAI(api_key=api_key)

    response = client.embeddings.create(
        input=text,
        model=model
    )

    embedding = np.array(response.data[0].embedding)
    return embedding
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py::test_load_api_key -v</code></p>
<p>Expected: PASS</p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py::test_embed_text -v</code></p>
<p>Expected: PASS (makes real API call, may take a few seconds)</p>
<p><strong>Step 5: Run all embedding tests</strong></p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/embedding/openai_embedder.py tests/test_openai_embedder.py
git commit -m &quot;feat: add OpenAI embedding generation&quot;
</code></pre>
<hr />
<h3 id="task-42-batch-path-embedding">Task 4.2: Batch Path Embedding</h3>
<p><strong>Files:</strong>
- Modify: <code>src/path_embedding/embedding/openai_embedder.py</code>
- Modify: <code>tests/test_openai_embedder.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Add to <code>tests/test_openai_embedder.py</code>:</p>
<pre><code class="language-python">from path_embedding.embedding.openai_embedder import embed_paths
from path_embedding.data.drugmechdb import load_drugmechdb
from path_embedding.utils.path_extraction import build_multigraph, extract_paths


def test_embed_paths():
    &quot;&quot;&quot;Test embedding multiple paths.

    Note: Makes real API calls, may be slow.
    &quot;&quot;&quot;
    key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)

    # Load sample paths
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        indication_paths = extract_paths(graph, indication[&quot;_id&quot;], max_paths=1)
        paths.extend(indication_paths)

    embeddings = embed_paths(paths, key)

    # Should return 2D array: n_paths x embedding_dim
    assert isinstance(embeddings, np.ndarray)
    assert len(embeddings.shape) == 2
    assert embeddings.shape[0] == len(paths)
    assert embeddings.shape[1] == 1536  # text-embedding-3-small dimension


def test_embed_paths_integration():
    &quot;&quot;&quot;Integration test with text formatter.&quot;&quot;&quot;
    key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)

    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)
    graph = build_multigraph(indications[0])
    paths = extract_paths(graph, indications[0][&quot;_id&quot;])

    embeddings = embed_paths(paths, key)

    assert embeddings.shape[0] == len(paths)
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py::test_embed_paths -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'embed_paths'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Add to <code>src/path_embedding/embedding/openai_embedder.py</code>:</p>
<pre><code class="language-python">from typing import List
from path_embedding.datamodel.types import Path
from path_embedding.embedding.text_formatter import path_to_text


def embed_paths(
    paths: List[Path],
    api_key: str,
    model: str = &quot;text-embedding-3-small&quot;
) -&gt; np.ndarray:
    &quot;&quot;&quot;Generate embeddings for multiple paths.

    Args:
        paths: List of Path objects
        api_key: OpenAI API key
        model: OpenAI embedding model

    Returns:
        2D numpy array of shape (n_paths, embedding_dim)

    Example:
        &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
        &gt;&gt;&gt; nodes = [
        ...     Node(id=&quot;A&quot;, label=&quot;Drug&quot;, name=&quot;aspirin&quot;),
        ...     Node(id=&quot;B&quot;, label=&quot;Protein&quot;, name=&quot;COX2&quot;),
        ...     Node(id=&quot;C&quot;, label=&quot;Disease&quot;, name=&quot;pain&quot;)
        ... ]
        &gt;&gt;&gt; edges = [
        ...     Edge(key=&quot;inhibits&quot;, source=&quot;A&quot;, target=&quot;B&quot;),
        ...     Edge(key=&quot;causes&quot;, source=&quot;B&quot;, target=&quot;C&quot;)
        ... ]
        &gt;&gt;&gt; path = Path(nodes=nodes, edges=edges, drug_id=&quot;A&quot;,
        ...             disease_id=&quot;C&quot;, indication_id=&quot;test&quot;)
        &gt;&gt;&gt; key = load_api_key(&quot;/Users/jtr4v/openai.key.another&quot;)
        &gt;&gt;&gt; embs = embed_paths([path], key)
        &gt;&gt;&gt; embs.shape[0] == 1
        True
    &quot;&quot;&quot;
    embeddings = []

    for path in paths:
        # Convert path to text
        text = path_to_text(path)

        # Generate embedding
        embedding = embed_text(text, api_key, model)
        embeddings.append(embedding)

    # Stack into 2D array
    return np.vstack(embeddings)
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py::test_embed_paths -v</code></p>
<p>Expected: PASS (makes API calls)</p>
<p><strong>Step 5: Run all tests</strong></p>
<p>Run: <code>uv run pytest tests/test_openai_embedder.py -v</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/embedding/openai_embedder.py tests/test_openai_embedder.py
git commit -m &quot;feat: add batch path embedding&quot;
</code></pre>
<hr />
<h2 id="phase-5-traintest-split">Phase 5: Train/Test Split</h2>
<h3 id="task-51-indication-level-splitting">Task 5.1: Indication-Level Splitting</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/model/__init__.py</code>
- Create: <code>src/path_embedding/model/data_split.py</code>
- Test: <code>tests/test_data_split.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_data_split.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for train/test splitting.&quot;&quot;&quot;
from path_embedding.model.data_split import split_by_indication
from path_embedding.data.drugmechdb import load_drugmechdb
from path_embedding.utils.path_extraction import build_multigraph, extract_paths


def test_split_by_indication():
    &quot;&quot;&quot;Test splitting paths by indication.

    &gt;&gt;&gt; from path_embedding.datamodel.types import Node, Edge, Path
    &gt;&gt;&gt; paths = [
    ...     Path(nodes=[], edges=[], drug_id=&quot;D1&quot;, disease_id=&quot;DIS1&quot;,
    ...          indication_id=&quot;ind1&quot;),
    ...     Path(nodes=[], edges=[], drug_id=&quot;D1&quot;, disease_id=&quot;DIS1&quot;,
    ...          indication_id=&quot;ind1&quot;),
    ...     Path(nodes=[], edges=[], drug_id=&quot;D2&quot;, disease_id=&quot;DIS2&quot;,
    ...          indication_id=&quot;ind2&quot;),
    ... ]
    &gt;&gt;&gt; train, test = split_by_indication(paths, test_size=0.5, random_seed=42)
    &gt;&gt;&gt; len(train) + len(test) == 3
    True
    &quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)

    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    train_paths, test_paths = split_by_indication(
        all_paths,
        test_size=0.2,
        random_seed=42
    )

    # Should have train and test
    assert len(train_paths) &gt; 0
    assert len(test_paths) &gt; 0

    # Total should equal input
    assert len(train_paths) + len(test_paths) == len(all_paths)


def test_split_by_indication_no_leakage():
    &quot;&quot;&quot;Test that same indication doesn't appear in both train and test.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)

    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    train_paths, test_paths = split_by_indication(
        all_paths,
        test_size=0.5,
        random_seed=42
    )

    # Get indication IDs from train and test
    train_indications = set(p.indication_id for p in train_paths)
    test_indications = set(p.indication_id for p in test_paths)

    # Should have no overlap
    assert len(train_indications &amp; test_indications) == 0


def test_split_by_indication_reproducible():
    &quot;&quot;&quot;Test that split is reproducible with same seed.&quot;&quot;&quot;
    indications = load_drugmechdb(&quot;tests/data/sample_drugmechdb.yaml&quot;)

    all_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;])
        all_paths.extend(paths)

    train1, test1 = split_by_indication(all_paths, test_size=0.5, random_seed=42)
    train2, test2 = split_by_indication(all_paths, test_size=0.5, random_seed=42)

    # Same seed should give same split
    assert len(train1) == len(train2)
    assert len(test1) == len(test2)

    train_ids_1 = [p.indication_id for p in train1]
    train_ids_2 = [p.indication_id for p in train2]
    assert train_ids_1 == train_ids_2
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_data_split.py -v</code></p>
<p>Expected: FAIL with "ModuleNotFoundError: No module named 'path_embedding.model'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create directory: <code>mkdir -p src/path_embedding/model</code></p>
<p>Create file <code>src/path_embedding/model/__init__.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Model training and evaluation modules.&quot;&quot;&quot;
</code></pre>
<p>Create file <code>src/path_embedding/model/data_split.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Train/test splitting by indication.&quot;&quot;&quot;
from typing import List, Tuple
from collections import defaultdict
import random
from path_embedding.datamodel.types import Path


def split_by_indication(
    paths: List[Path],
    test_size: float = 0.2,
    random_seed: int = 42
) -&gt; Tuple[List[Path], List[Path]]:
    &quot;&quot;&quot;Split paths into train/test by indication (drug-disease pair).

    Groups paths by indication_id, then splits at indication level to
    prevent data leakage.

    Args:
        paths: List of Path objects
        test_size: Fraction for test set (default 0.2)
        random_seed: Random seed for reproducibility

    Returns:
        Tuple of (train_paths, test_paths)

    Example:
        &gt;&gt;&gt; from path_embedding.datamodel.types import Path
        &gt;&gt;&gt; paths = [
        ...     Path(nodes=[], edges=[], drug_id=&quot;D1&quot;, disease_id=&quot;DIS1&quot;,
        ...          indication_id=&quot;ind1&quot;),
        ...     Path(nodes=[], edges=[], drug_id=&quot;D2&quot;, disease_id=&quot;DIS2&quot;,
        ...          indication_id=&quot;ind2&quot;),
        ... ]
        &gt;&gt;&gt; train, test = split_by_indication(paths, test_size=0.5, random_seed=42)
        &gt;&gt;&gt; len(train) + len(test) == 2
        True
    &quot;&quot;&quot;
    random.seed(random_seed)

    # Group paths by indication_id
    indication_groups = defaultdict(list)
    for path in paths:
        indication_groups[path.indication_id].append(path)

    # Get list of indication IDs
    indication_ids = list(indication_groups.keys())

    # Shuffle and split indication IDs
    random.shuffle(indication_ids)
    split_point = int(len(indication_ids) * (1 - test_size))

    train_indication_ids = indication_ids[:split_point]
    test_indication_ids = indication_ids[split_point:]

    # Collect paths for train and test
    train_paths = []
    for ind_id in train_indication_ids:
        train_paths.extend(indication_groups[ind_id])

    test_paths = []
    for ind_id in test_indication_ids:
        test_paths.extend(indication_groups[ind_id])

    return train_paths, test_paths
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_data_split.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_data_split.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/model/ tests/test_data_split.py
git commit -m &quot;feat: add indication-level train/test split&quot;
</code></pre>
<hr />
<h2 id="phase-6-classifier-training-and-evaluation">Phase 6: Classifier Training and Evaluation</h2>
<h3 id="task-61-random-forest-classifier">Task 6.1: Random Forest Classifier</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/model/classifier.py</code>
- Test: <code>tests/test_classifier.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_classifier.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for classifier training.&quot;&quot;&quot;
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from path_embedding.model.classifier import train_classifier


def test_train_classifier():
    &quot;&quot;&quot;Test training Random Forest classifier.

    &gt;&gt;&gt; X = np.random.rand(100, 10)
    &gt;&gt;&gt; y = np.random.randint(0, 2, 100)
    &gt;&gt;&gt; model = train_classifier(X, y)
    &gt;&gt;&gt; isinstance(model, RandomForestClassifier)
    True
    &quot;&quot;&quot;
    # Create synthetic data
    X_train = np.random.rand(100, 10)
    y_train = np.random.randint(0, 2, 100)

    model = train_classifier(X_train, y_train)

    assert isinstance(model, RandomForestClassifier)

    # Should be able to make predictions
    predictions = model.predict(X_train)
    assert predictions.shape[0] == 100


def test_train_classifier_predictions():
    &quot;&quot;&quot;Test that trained model can make predictions.&quot;&quot;&quot;
    X_train = np.random.rand(50, 10)
    y_train = np.random.randint(0, 2, 50)

    model = train_classifier(X_train, y_train)

    X_test = np.random.rand(10, 10)
    predictions = model.predict(X_test)

    assert predictions.shape[0] == 10
    # Predictions should be 0 or 1
    assert all(p in [0, 1] for p in predictions)


def test_train_classifier_probabilities():
    &quot;&quot;&quot;Test that model can output probabilities.&quot;&quot;&quot;
    X_train = np.random.rand(50, 10)
    y_train = np.random.randint(0, 2, 50)

    model = train_classifier(X_train, y_train)

    X_test = np.random.rand(10, 10)
    probs = model.predict_proba(X_test)

    assert probs.shape == (10, 2)
    # Probabilities should sum to 1
    assert np.allclose(probs.sum(axis=1), 1.0)
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_classifier.py -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'train_classifier'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create file <code>src/path_embedding/model/classifier.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Classifier training and prediction.&quot;&quot;&quot;
import numpy as np
from sklearn.ensemble import RandomForestClassifier


def train_classifier(
    X_train: np.ndarray,
    y_train: np.ndarray,
    random_state: int = 42
) -&gt; RandomForestClassifier:
    &quot;&quot;&quot;Train Random Forest classifier.

    Args:
        X_train: Training features (n_samples, n_features)
        y_train: Training labels (n_samples,)
        random_state: Random seed for reproducibility

    Returns:
        Trained RandomForestClassifier

    Example:
        &gt;&gt;&gt; X = np.random.rand(50, 10)
        &gt;&gt;&gt; y = np.random.randint(0, 2, 50)
        &gt;&gt;&gt; model = train_classifier(X, y)
        &gt;&gt;&gt; isinstance(model, RandomForestClassifier)
        True
    &quot;&quot;&quot;
    model = RandomForestClassifier(random_state=random_state)
    model.fit(X_train, y_train)
    return model
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_classifier.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_classifier.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/model/classifier.py tests/test_classifier.py
git commit -m &quot;feat: add Random Forest classifier training&quot;
</code></pre>
<hr />
<h3 id="task-62-evaluation-metrics">Task 6.2: Evaluation Metrics</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/model/evaluation.py</code>
- Test: <code>tests/test_evaluation.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_evaluation.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for model evaluation.&quot;&quot;&quot;
import numpy as np
from path_embedding.model.evaluation import evaluate_classifier
from path_embedding.model.classifier import train_classifier


def test_evaluate_classifier():
    &quot;&quot;&quot;Test evaluating classifier with metrics.

    &gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
    &gt;&gt;&gt; X = np.random.rand(50, 10)
    &gt;&gt;&gt; y = np.array([0] * 25 + [1] * 25)
    &gt;&gt;&gt; model = RandomForestClassifier(random_state=42)
    &gt;&gt;&gt; model.fit(X, y)
    RandomForestClassifier(random_state=42)
    &gt;&gt;&gt; metrics = evaluate_classifier(model, X, y)
    &gt;&gt;&gt; &quot;accuracy&quot; in metrics
    True
    &quot;&quot;&quot;
    # Create simple dataset
    X_train = np.random.rand(100, 10)
    y_train = np.array([0] * 50 + [1] * 50)

    model = train_classifier(X_train, y_train)

    X_test = np.random.rand(50, 10)
    y_test = np.array([0] * 25 + [1] * 25)

    metrics = evaluate_classifier(model, X_test, y_test)

    # Should have all expected metrics
    assert &quot;accuracy&quot; in metrics
    assert &quot;precision&quot; in metrics
    assert &quot;recall&quot; in metrics
    assert &quot;f1&quot; in metrics
    assert &quot;roc_auc&quot; in metrics

    # All metrics should be between 0 and 1
    for metric_name, value in metrics.items():
        assert 0 &lt;= value &lt;= 1, f&quot;{metric_name} out of range&quot;


def test_evaluate_classifier_perfect():
    &quot;&quot;&quot;Test with perfect predictions.&quot;&quot;&quot;
    # Create separable data
    X_train = np.vstack([
        np.random.rand(50, 10) - 1,  # Class 0
        np.random.rand(50, 10) + 1,  # Class 1
    ])
    y_train = np.array([0] * 50 + [1] * 50)

    model = train_classifier(X_train, y_train)

    # Test on training data (should be nearly perfect)
    metrics = evaluate_classifier(model, X_train, y_train)

    # Should have high accuracy
    assert metrics[&quot;accuracy&quot;] &gt; 0.8
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_evaluation.py -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'evaluate_classifier'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create file <code>src/path_embedding/model/evaluation.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Model evaluation utilities.&quot;&quot;&quot;
from typing import Dict
import numpy as np
from sklearn.metrics import (
    accuracy_score,
    precision_score,
    recall_score,
    f1_score,
    roc_auc_score,
    classification_report,
    confusion_matrix
)


def evaluate_classifier(
    model,
    X_test: np.ndarray,
    y_test: np.ndarray
) -&gt; Dict[str, float]:
    &quot;&quot;&quot;Evaluate classifier and return metrics.

    Args:
        model: Trained classifier with predict() and predict_proba()
        X_test: Test features
        y_test: Test labels

    Returns:
        Dict with accuracy, precision, recall, f1, roc_auc

    Example:
        &gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
        &gt;&gt;&gt; X = np.random.rand(50, 10)
        &gt;&gt;&gt; y = np.array([0] * 25 + [1] * 25)
        &gt;&gt;&gt; model = RandomForestClassifier(random_state=42).fit(X, y)
        &gt;&gt;&gt; metrics = evaluate_classifier(model, X, y)
        &gt;&gt;&gt; &quot;accuracy&quot; in metrics
        True
    &quot;&quot;&quot;
    # Get predictions
    y_pred = model.predict(X_test)
    y_proba = model.predict_proba(X_test)[:, 1]

    # Calculate metrics
    metrics = {
        &quot;accuracy&quot;: accuracy_score(y_test, y_pred),
        &quot;precision&quot;: precision_score(y_test, y_pred, zero_division=0),
        &quot;recall&quot;: recall_score(y_test, y_pred, zero_division=0),
        &quot;f1&quot;: f1_score(y_test, y_pred, zero_division=0),
        &quot;roc_auc&quot;: roc_auc_score(y_test, y_proba),
    }

    return metrics


def print_evaluation_report(
    model,
    X_test: np.ndarray,
    y_test: np.ndarray
) -&gt; None:
    &quot;&quot;&quot;Print detailed evaluation report.

    Args:
        model: Trained classifier
        X_test: Test features
        y_test: Test labels
    &quot;&quot;&quot;
    y_pred = model.predict(X_test)

    print(&quot;\n=== Classification Report ===&quot;)
    print(classification_report(y_test, y_pred, target_names=[&quot;Implausible&quot;, &quot;Plausible&quot;]))

    print(&quot;\n=== Confusion Matrix ===&quot;)
    cm = confusion_matrix(y_test, y_pred)
    print(cm)

    print(&quot;\n=== Metrics Summary ===&quot;)
    metrics = evaluate_classifier(model, X_test, y_test)
    for metric_name, value in metrics.items():
        print(f&quot;{metric_name}: {value:.4f}&quot;)
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_evaluation.py -v</code></p>
<p>Expected: PASS (all tests)</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_evaluation.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/model/evaluation.py tests/test_evaluation.py
git commit -m &quot;feat: add classifier evaluation metrics&quot;
</code></pre>
<hr />
<h2 id="phase-7-cli-integration">Phase 7: CLI Integration</h2>
<h3 id="task-71-training-command">Task 7.1: Training Command</h3>
<p><strong>Files:</strong>
- Modify: <code>src/path_embedding/cli.py</code>
- Test: <code>tests/test_cli.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_cli.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for CLI commands.&quot;&quot;&quot;
import os
import tempfile
from typer.testing import CliRunner
from path_embedding.cli import app

runner = CliRunner()


def test_train_command_help():
    &quot;&quot;&quot;Test that train command shows help.&quot;&quot;&quot;
    result = runner.invoke(app, [&quot;train&quot;, &quot;--help&quot;])
    assert result.exit_code == 0
    assert &quot;train&quot; in result.stdout.lower()


def test_train_command_integration():
    &quot;&quot;&quot;Integration test for train command.

    Note: This makes real API calls and may be slow/expensive.
    &quot;&quot;&quot;
    with tempfile.TemporaryDirectory() as tmpdir:
        model_path = os.path.join(tmpdir, &quot;test_model.pkl&quot;)

        result = runner.invoke(app, [
            &quot;train&quot;,
            &quot;--data&quot;, &quot;tests/data/sample_drugmechdb.yaml&quot;,
            &quot;--output&quot;, model_path,
            &quot;--test-size&quot;, &quot;0.5&quot;,
            &quot;--max-paths-per-indication&quot;, &quot;1&quot;,
            &quot;--api-key-path&quot;, &quot;/Users/jtr4v/openai.key.another&quot;
        ])

        # Should succeed
        assert result.exit_code == 0

        # Model file should be created
        assert os.path.exists(model_path)
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_cli.py::test_train_command_help -v</code></p>
<p>Expected: FAIL (train command doesn't exist yet)</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Modify <code>src/path_embedding/cli.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;CLI interface for path-embedding.&quot;&quot;&quot;

import typer
from typing_extensions import Annotated
from pathlib import Path
import pickle
import numpy as np

app = typer.Typer(help=&quot;path-embedding: Classifier that uses embeddings to find useful paths between drugs and disease&quot;)


@app.command()
def train(
    data: Annotated[str, typer.Option(help=&quot;Path to DrugMechDB YAML file&quot;)],
    output: Annotated[str, typer.Option(help=&quot;Path to save trained model (.pkl)&quot;)],
    api_key_path: Annotated[str, typer.Option(help=&quot;Path to OpenAI API key file&quot;)] = &quot;/Users/jtr4v/openai.key.another&quot;,
    test_size: Annotated[float, typer.Option(help=&quot;Fraction for test set&quot;)] = 0.2,
    max_paths_per_indication: Annotated[int, typer.Option(help=&quot;Max paths to extract per indication&quot;)] = 10,
    random_seed: Annotated[int, typer.Option(help=&quot;Random seed&quot;)] = 42,
):
    &quot;&quot;&quot;Train path embedding classifier on DrugMechDB data.&quot;&quot;&quot;
    from path_embedding.data.drugmechdb import load_drugmechdb
    from path_embedding.utils.path_extraction import build_multigraph, extract_paths
    from path_embedding.data.negative_sampling import generate_negatives
    from path_embedding.model.data_split import split_by_indication
    from path_embedding.embedding.openai_embedder import load_api_key, embed_paths
    from path_embedding.model.classifier import train_classifier
    from path_embedding.model.evaluation import evaluate_classifier, print_evaluation_report

    typer.echo(&quot;Loading DrugMechDB data...&quot;)
    indications = load_drugmechdb(data)
    typer.echo(f&quot;Loaded {len(indications)} indications&quot;)

    typer.echo(&quot;Extracting paths from multigraphs...&quot;)
    all_positive_paths = []
    for indication in indications:
        graph = build_multigraph(indication)
        paths = extract_paths(graph, indication[&quot;_id&quot;], max_paths=max_paths_per_indication)
        all_positive_paths.extend(paths)
    typer.echo(f&quot;Extracted {len(all_positive_paths)} positive paths&quot;)

    typer.echo(&quot;Generating negative examples...&quot;)
    negative_paths = generate_negatives(all_positive_paths)
    typer.echo(f&quot;Generated {len(negative_paths)} negative paths&quot;)

    typer.echo(&quot;Splitting train/test by indication...&quot;)
    train_pos, test_pos = split_by_indication(all_positive_paths, test_size=test_size, random_seed=random_seed)
    train_neg, test_neg = split_by_indication(negative_paths, test_size=test_size, random_seed=random_seed)

    train_paths = train_pos + train_neg
    test_paths = test_pos + test_neg

    train_labels = np.array([1] * len(train_pos) + [0] * len(train_neg))
    test_labels = np.array([1] * len(test_pos) + [0] * len(test_neg))

    typer.echo(f&quot;Train: {len(train_paths)} paths ({len(train_pos)} pos, {len(train_neg)} neg)&quot;)
    typer.echo(f&quot;Test: {len(test_paths)} paths ({len(test_pos)} pos, {len(test_neg)} neg)&quot;)

    typer.echo(&quot;Loading API key...&quot;)
    api_key = load_api_key(api_key_path)

    typer.echo(&quot;Generating embeddings for training set...&quot;)
    train_embeddings = embed_paths(train_paths, api_key)
    typer.echo(f&quot;Train embeddings shape: {train_embeddings.shape}&quot;)

    typer.echo(&quot;Generating embeddings for test set...&quot;)
    test_embeddings = embed_paths(test_paths, api_key)
    typer.echo(f&quot;Test embeddings shape: {test_embeddings.shape}&quot;)

    typer.echo(&quot;Training Random Forest classifier...&quot;)
    model = train_classifier(train_embeddings, train_labels, random_state=random_seed)

    typer.echo(&quot;Evaluating on test set...&quot;)
    print_evaluation_report(model, test_embeddings, test_labels)

    typer.echo(f&quot;Saving model to {output}...&quot;)
    with open(output, 'wb') as f:
        pickle.dump(model, f)

    typer.echo(&quot;Training complete!&quot;)


def main():
    &quot;&quot;&quot;Main entry point for the CLI.&quot;&quot;&quot;
    app()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_cli.py::test_train_command_help -v</code></p>
<p>Expected: PASS</p>
<p>Run full integration test (this will make API calls):
<code>uv run pytest tests/test_cli.py::test_train_command_integration -v</code></p>
<p>Expected: PASS (may take time due to API calls)</p>
<p><strong>Step 5: Test manually</strong></p>
<p>Run: <code>uv run path-embedding train --help</code></p>
<p>Expected: Shows help for train command</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/cli.py tests/test_cli.py
git commit -m &quot;feat: add train CLI command&quot;
</code></pre>
<hr />
<h2 id="phase-8-kgx-stub">Phase 8: KGX Stub</h2>
<h3 id="task-81-kgx-loader-stub">Task 8.1: KGX Loader Stub</h3>
<p><strong>Files:</strong>
- Create: <code>src/path_embedding/data/kgx.py</code>
- Test: <code>tests/test_kgx.py</code></p>
<p><strong>Step 1: Write the failing test</strong></p>
<p>Create file <code>tests/test_kgx.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;Tests for KGX data loading (stub).&quot;&quot;&quot;
import pytest
from path_embedding.data.kgx import load_kgx_paths


def test_load_kgx_paths_not_implemented():
    &quot;&quot;&quot;Test that KGX loader raises NotImplementedError.

    &gt;&gt;&gt; load_kgx_paths(&quot;dummy.json&quot;)
    Traceback (most recent call last):
        ...
    NotImplementedError: KGX support not yet implemented
    &quot;&quot;&quot;
    with pytest.raises(NotImplementedError):
        load_kgx_paths(&quot;dummy.json&quot;)
</code></pre>
<p><strong>Step 2: Run test to verify it fails</strong></p>
<p>Run: <code>uv run pytest tests/test_kgx.py -v</code></p>
<p>Expected: FAIL with "ImportError: cannot import name 'load_kgx_paths'"</p>
<p><strong>Step 3: Write minimal implementation</strong></p>
<p>Create file <code>src/path_embedding/data/kgx.py</code>:</p>
<pre><code class="language-python">&quot;&quot;&quot;KGX format data loading (stub for future implementation).

KGX (Knowledge Graph Exchange) format support will be added in a future version.
This module provides stubs to document the planned interface.

Expected KGX format:
- Nodes: JSON/TSV with id, category, name fields
- Edges: JSON/TSV with subject, predicate, object fields

Future implementation will:
1. Load KGX nodes and edges
2. Construct paths from edge sequences
3. Convert to Path objects matching DrugMechDB format
&quot;&quot;&quot;
from typing import List
from path_embedding.datamodel.types import Path


def load_kgx_paths(file_path: str) -&gt; List[Path]:
    &quot;&quot;&quot;Load paths from KGX format file.

    Args:
        file_path: Path to KGX JSON or TSV file

    Returns:
        List of Path objects

    Raises:
        NotImplementedError: KGX support not yet implemented

    Example:
        &gt;&gt;&gt; load_kgx_paths(&quot;paths.kgx.json&quot;)
        Traceback (most recent call last):
            ...
        NotImplementedError: KGX support not yet implemented
    &quot;&quot;&quot;
    raise NotImplementedError(&quot;KGX support not yet implemented&quot;)
</code></pre>
<p><strong>Step 4: Run test to verify it passes</strong></p>
<p>Run: <code>uv run pytest tests/test_kgx.py -v</code></p>
<p>Expected: PASS</p>
<p><strong>Step 5: Run doctests</strong></p>
<p>Run: <code>uv run pytest tests/test_kgx.py --doctest-modules</code></p>
<p>Expected: PASS</p>
<p><strong>Step 6: Commit</strong></p>
<pre><code class="language-bash">git add src/path_embedding/data/kgx.py tests/test_kgx.py
git commit -m &quot;feat: add KGX loader stub for future implementation&quot;
</code></pre>
<hr />
<h2 id="final-steps">Final Steps</h2>
<h3 id="task-91-run-full-test-suite">Task 9.1: Run Full Test Suite</h3>
<p><strong>Step 1: Run all tests</strong></p>
<p>Run: <code>just test</code></p>
<p>Expected: All tests pass, type checking passes, formatting passes</p>
<p><strong>Step 2: If any failures, fix them</strong></p>
<p>Address any test failures, type errors, or formatting issues.</p>
<p><strong>Step 3: Commit fixes</strong></p>
<pre><code class="language-bash">git add .
git commit -m &quot;fix: address test/typing/formatting issues&quot;
</code></pre>
<hr />
<h3 id="task-92-create-data-and-models-directories">Task 9.2: Create Data and Models Directories</h3>
<p><strong>Step 1: Create directories</strong></p>
<p>Run:</p>
<pre><code class="language-bash">mkdir -p data models
echo &quot;# DrugMechDB data files&quot; &gt; data/README.md
echo &quot;# Trained models&quot; &gt; models/README.md
</code></pre>
<p><strong>Step 2: Add to git</strong></p>
<pre><code class="language-bash">git add data/README.md models/README.md
git commit -m &quot;chore: add data and models directories&quot;
</code></pre>
<hr />
<h3 id="task-93-update-documentation">Task 9.3: Update Documentation</h3>
<p><strong>Step 1: Verify README is up to date</strong></p>
<p>Check that <code>README.md</code> matches what was written earlier.</p>
<p><strong>Step 2: Verify design doc is complete</strong></p>
<p>Check <code>docs/plans/2025-11-10-path-embedding-classifier-design.md</code></p>
<p><strong>Step 3: Add usage examples to docs</strong></p>
<p>Create <code>docs/usage.md</code> with examples of how to use the CLI.</p>
<p><strong>Step 4: Commit</strong></p>
<pre><code class="language-bash">git add docs/
git commit -m &quot;docs: add usage examples&quot;
</code></pre>
<hr />
<h2 id="success-criteria">Success Criteria</h2>
<p>After completing all tasks:</p>
<ul>
<li>[ ] All tests pass: <code>just test</code></li>
<li>[ ] Type checking passes: <code>just mypy</code></li>
<li>[ ] Formatting passes: <code>just format</code></li>
<li>[ ] Can train model: <code>uv run path-embedding train --data &lt;file&gt; --output model.pkl</code></li>
<li>[ ] Model saves successfully</li>
<li>[ ] Evaluation metrics printed</li>
<li>[ ] README updated</li>
<li>[ ] Design document complete</li>
<li>[ ] All commits made with clear messages</li>
</ul>
<hr />
<h2 id="notes">Notes</h2>
<ul>
<li><strong>API Costs</strong>: The embedding generation makes real OpenAI API calls. Use small test datasets during development to minimize costs.</li>
<li><strong>Test Data</strong>: The <code>tests/data/sample_drugmechdb.yaml</code> fixture contains only 2 indications. For real training, download the full DrugMechDB YAML file.</li>
<li><strong>Random Seeds</strong>: All random operations use seeds for reproducibility (42 default).</li>
<li><strong>Future Work</strong>: KGX support, node enrichment, alternative classifiers are noted but not implemented.</li>
</ul>
<hr />
<h2 id="execution">Execution</h2>
<p><strong>Plan complete and saved to <code>docs/plans/2025-11-10-path-embedding-implementation.md</code>.</strong></p>
<p><strong>Two execution options:</strong></p>
<p><strong>1. Subagent-Driven (this session)</strong> - I dispatch fresh subagent per task, review between tasks, fast iteration</p>
<p><strong>2. Parallel Session (separate)</strong> - Open new session with executing-plans, batch execution with checkpoints</p>
<p><strong>Which approach?</strong></p>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["content.tabs.link"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>